---
marp: true
theme: default
paginate: true
---

# Autodock Vina 源码解析

---

## 整体流程

1. 检查参数，初始化`Vina`类
2. 解析受体：`v.set_receptor`
3. 解析配体：`v.set_ligand_from_file`
4. 分别进行`model`的初始化
5. 将得到的多个`model`合并
6. 加载配体`map`：`v.load_maps`；若没有则计算`map`：`v.compute_vina_maps`
7. 根据设置调用具体的计算，默认为`v.global_search`+`v.write_poses`

---

## 初始化

**构造函数参数说明：**

- `sf_name`: 评分函数名称，可以为"vina"/"vinardo"/"ad4"，会自动设置对应的默认权重
- `cpu`：使用的cpu线程数，默认使用全部
- `seed`：用于生成随机数的种子
- `verbosity`：日志级别
- `no_refine`：是否启用精细计算，默认false为启用
- `progress_callback`：回调函数，目前的代码中全部都是`NULL`

```cpp
Vina(const std::string &sf_name="vina", 
     int cpu=0, 
     int seed=0, 
     int verbosity=1, 
     bool no_refine=false, 
     std::function<void(double)>* progress_callback = NULL)
```

---

## 解析受体/配体

**核心函数**
解析配体/受体并把解析结果以`model`对象的格式返回，有三个核心函数：

- 读文件解析配体：`model parse_ligand_pdbqt_from_file(const std::string& name, atom_type::t atype)`
- 读字符串解析配体：`model parse_ligand_pdbqt_from_string(const std::string& string_name, atom_type::t atype)`
- 读文件解析受体：`model parse_receptor_pdbqt(const std::string& rigid_name, const std::string& flex_name, atom_type::t atype)`

---

## 解析流程

**不管是对于受体还是配体的解析，遵循以下的流程：**

1. 解析输入到一个数据结构中`rigid`/`parsing_struct`
2. （把`parsing_struct`转换为`non_rigid_parsed`）
3. 用该数据结构初始化一个`model`

---

## pdbqt文件格式

### 受体刚性示例

**刚体部分往往都是认为固定不动的，所以其pdbqt文件含有信息的行就只有一个个的`ATOM`行**

```
ATOM      1  N   ALA A   1      20.154  15.234   8.123  0.00  0.00    -0.347 N 
ATOM      2  CA  ALA A   1      19.876  16.543   8.754  0.00  0.00     0.221 C 
ATOM      3  C   ALA A   1      18.456  16.612   9.295  0.00  0.00     0.763 C 
ATOM      4  O   ALA A   1      17.512  16.012   8.876  0.00  0.00    -0.801 O 
ATOM      5  CB  ALA A   1      20.087  17.701   7.832  0.00  0.00     0.037 C 
ATOM      6  N   VAL A   2      18.321  17.432  10.341  0.00  0.00    -0.347 N 
ATOM      7  CA  VAL A   2      17.032  17.634  11.012  0.00  0.00     0.221 C 
ATOM      8  C   VAL A   2      16.987  16.743  12.245  0.00  0.00     0.763 C 
ATOM      9  O   VAL A   2      17.912  16.543  12.987  0.00  0.00    -0.801 O 
ATOM     10  CB  VAL A   2      16.832  19.076  11.432  0.00  0.00     0.012 C 
ATOM     11  CG1 VAL A   2      15.543  19.234  12.187  0.00  0.00     0.024 C 
ATOM     12  CG2 VAL A   2      16.789  20.043  10.287  0.00  0.00     0.024 C 
TER
```

---

## 配体示例

**用`ROOT`和`BRANCH`来表示树状的结构，最后的`TORSDOF`是该配体的扭转度**

```
ROOT
ATOM      1  C1  LIG A   1      15.432  18.234  16.123  0.00  0.00     0.170 A 
ATOM      2  C2  LIG A   1      16.765  17.876  16.432  0.00  0.00     0.050 A 
ATOM      3  C3  LIG A   1      17.234  16.654  16.876  0.00  0.00     0.007 A 
ATOM      4  C4  LIG A   1      16.432  15.543  17.123  0.00  0.00     0.000 A 
ATOM      5  C5  LIG A   1      15.123  15.876  16.876  0.00  0.00     0.007 A 
ATOM      6  C6  LIG A   1      14.654  17.123  16.432  0.00  0.00     0.050 A 
ENDROOT
BRANCH   2   7
ATOM      7  C7  LIG A   1      17.543  19.087  16.123  0.00  0.00     0.308 C 
BRANCH   7   8
ATOM      8  C8  LIG A   1      18.876  19.234  16.876  0.00  0.00     0.253 C 
ATOM      9  O9  LIG A   1      19.123  18.765  17.987  0.00  0.00    -0.270 OA
ENDBRANCH   7   8
ENDBRANCH   2   7
BRANCH   1  10
ATOM     10  O10 LIG A   1      14.876  19.432  15.765  0.00  0.00    -0.356 OA
ATOM     11  H10 LIG A   1      14.123  19.654  16.234  0.00  0.00     0.218 HD
ENDBRANCH   1  10
TORSDOF 4
```

---

## 受体柔性残基示例

**可以认为是由一个个的`BEGIN_RES`和`END_RES`包裹的"配体"，只不过不会有`TORSDOF`行**

---

## 受体刚性解析

<div style="display: flex; align-items: flex-start;">
<div style="flex: 1; padding-right: 20px;">

**解析逻辑：**
解析结果用`rigid`存储，非常简单的结构体。

遇到`ATOM`或`HETATM`行就调用`parse_pdbqt_atom_string`将该行解析为一个原子，并将其放入`rigid`结构体中的`atoms`字段

`parse_pdbqt_atom_string`的作用就是将参数的字符串解析出原子索引、三维坐标、电荷、原子类型，并创建`parsed_atom`对象存入这些信息

</div>
<div style="flex: 1;">

```cpp
struct rigid {
    atomv atoms; ///< 刚性原子向量
};
```

</div>
</div>

---

## AutoDock Vina的原子表示

![Atom类图](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/202506172149777.png)

---

## 原子类型说明

- `atom_type`中保存原子在不同分类方案下的类型信息，还提供了获取该类型原子共价半径等与原子类型相关的方法
- `atom_base`：添加了电荷信息
- `atom`：添加了坐标与该原子所有的化学键
- `parsed_atom`：添加了`number`字段用于保存解析时的pdbqt的原子序号，解析时的默认原子，但最终只用于表示不可移动的原子
- `movable_atom`：添加了该原子相对刚体远点的坐标，一般是从`parsed_atom`强制转换过来用于描述可移动原子

---

## 配体/柔性残基解析

**由于配体和柔性残基几乎可以认为是元素和向量的关系，所以对柔性残基的解析可以在配体解析上扩展进行，基本的解析流程如下：**

1. 对于配体或者受体的每一个柔性残基，都分配一个`parsing_struct`，调用`parse_pdbqt_aux`解析
2. 先调用`parse_pdbqt_root`解析`ROOT`部分，之后按行解析
3. 若开头`BRANCH`则调用`parse_pdbqt_branch_aux`开始解析`BRANCH`
4. 若开头为`TORSDOF`且在解析配体则保存扭转自由度信息
5. 若是解析受体柔性残基且开头`END_RES`则终止；配体解析则到读完流的所有内容才终止

---

## parsing_struct

<div style="display: flex; align-items: flex-start;">
<div style="flex: 1; padding-right: 20px;">

**处理配体/柔性残基的核心数据结构**

它是一个树形结构，`atoms`中保存根部的所有节点，每个节点都包含一个原子和若干个子树

</div>
<div style="flex: 1;">

```cpp
struct parsing_struct {
    // 树形节点结构
    template<typename T>  // T 往往是parsing_struct
    struct node_t {
        sz context_index;           // 在上下文中的索引
        parsed_atom a;              // 节点包含的原子
        std::vector<T> ps;          // 子分支向量（递归结构）
    };
    typedef node_t<parsing_struct> node;
    
    boost::optional<sz> immobile_atom;           // 不可移动原子索引
    boost::optional<atom_reference> axis_begin;  // 旋转轴起始原子引用
    boost::optional<atom_reference> axis_end;    // 旋转轴结束原子引用
    std::vector<node> atoms;                     // 根节点向量
};
```

</div>
</div>

---

## ROOT解析

<div style="display: flex; align-items: flex-start;">
<div style="flex: 1; padding-right: 20px;">

**由于ROOT段中没有复杂的嵌套结构，所以解析方式类似刚体解析：**

检测到ROOT之后，对于每一行原子定义，直接调用`parse_pdbqt_atom_string`解析，然后把原子和上下文加入到`parsing_struct`中（调用`parsing_struct::add`）

</div>
<div style="flex: 1;">

```cpp
void parse_pdbqt_root_aux(std::istream& in, parsing_struct& p, context& c) {
    std::string str;

    while(std::getline(in, str)) {
        add_context(c, str);

        if(str.empty()) {} // 忽略空行
        else if(starts_with(str, "WARNING")) {} // 忽略WARNING行 - AutoDockTools bug workaround
        else if(starts_with(str, "REMARK")) {} // 忽略REMARK行
        else if(starts_with(str, "ATOM  ") || starts_with(str, "HETATM"))
            p.add(parse_pdbqt_atom_string(str), c);
        else if(starts_with(str, "ENDROOT"))
            return;
        else if(starts_with(str, "MODEL"))
            throw pdbqt_parse_error("Unexpected multi-MODEL tag found in flex residue or ligand PDBQT file. "
                                    "Use \"vina_split\" to split flex residues or ligands in multiple PDBQT files.");
        else 
            throw pdbqt_parse_error("Unknown or inappropriate tag found in flex residue or ligand.", str);
    }
}
```

</div>
</div>

---

## BRANCH解析

<div style="display: flex; align-items: flex-start;">
<div style="flex: 1; padding-right: 20px;">

**解析步骤：**

1. 调用`parse_pdbqt_branch_aux`解析`BRANCH`行，首先分析这个分支的父节点原子和该分支与父节点连接的原子
2. 通过索引找到父原子之后，给该父原子节点(`node`)的`ps`字段建立一个新的`parsing_struct`，代表这个子分支
3. 以新建的`parsing_struct`调用`parse_pdbqt_branch`解析这个分支中的原子
4. 解析原子仍然是调用`parse_pdbqt_atom_string`并把它加入到`parsing_struct`的`atoms`中。如果是与父结构相连的节点，还要将其索引放入`immobile_atom`；`parsing_struct`中的`axis_begin`和`axis_end`在后处理中才会被设置

</div>
<div style="flex: 1;">

```cpp
void parse_pdbqt_branch_aux(std::istream& in, const std::string& str, parsing_struct& p, context& c) {
    unsigned first, second;
    parse_two_unsigneds(str, "BRANCH", first, second);
    sz i = 0;

    // 查找起始原子编号对应的原子
    for(; i < p.atoms.size(); ++i)
        if(p.atoms[i].a.number == first) {
            p.atoms[i].ps.push_back(parsing_struct());
            parse_pdbqt_branch(in, p.atoms[i].ps.back(), c, first, second);
            break;
        }

    if(i == p.atoms.size())
        throw pdbqt_parse_error("Atom number " + std::to_string(first) + " is missing in this branch.", str);
}
```

</div>
</div>

---

## BRANCH解析（续）

```cpp
void parse_pdbqt_branch(std::istream& in, parsing_struct& p, context& c, unsigned from, unsigned to) {
    std::string str;

    while(std::getline(in, str)) {
        add_context(c, str);

        if(str.empty()) {} // 忽略空行
        else if(starts_with(str, "WARNING")) {} // 忽略WARNING行 - AutoDockTools bug workaround
        else if(starts_with(str, "REMARK")) {} // 忽略REMARK行
        else if(starts_with(str, "BRANCH")) parse_pdbqt_branch_aux(in, str, p, c);
        else if(starts_with(str, "ENDBRANCH")) {
            unsigned first, second;
            parse_two_unsigneds(str, "ENDBRANCH", first, second);
            if(first != from || second != to) 
                throw pdbqt_parse_error("Inconsistent branch numbers.");
            if(!p.immobile_atom) 
                throw pdbqt_parse_error("Atom " + boost::lexical_cast<std::string>(to) + " has not been found in this branch.");
            return;
        }
        else if(starts_with(str, "ATOM  ") || starts_with(str, "HETATM")) {
            parsed_atom a = parse_pdbqt_atom_string(str);
            // 将本分支与父节点连接的原子设为不可移动
            if(a.number == to)
                p.immobile_atom = p.atoms.size();
            p.add(a, c);
        }
        else if(starts_with(str, "MODEL"))
            throw pdbqt_parse_error("Unexpected multi-MODEL tag found in flex residue or ligand PDBQT file. "
                                    "Use \"vina_split\" to split flex residues or ligands in multiple PDBQT files.");
        else 
            throw pdbqt_parse_error("Unknown or inappropriate tag found in flex residue or ligand.", str);
    }
}
```

---

## 后处理

<div style="display: flex; align-items: flex-start;">
<div style="flex: 1; padding-right: 20px;">

**将配体或受体残基的解析树`parsing_struct`和扭转度信息转换为`non_rigid_parsed`结构**

</div>
<div style="flex: 1;">

```cpp
enum distance_type {
    DISTANCE_FIXED,    ///< 固定距离（如共价键）
    DISTANCE_ROTOR,    ///< 转子距离（可旋转键）
    DISTANCE_VARIABLE  ///< 可变距离（非键相互作用）
};
struct non_rigid_parsed {
    vector_mutable<ligand> ligands;  ///< 配体向量
    vector_mutable<residue> flex;    ///< 柔性残基向量
    
    mav atoms;     ///< 可移动原子向量
    atomv inflex;  ///< 不可移动原子向量

    distance_type_matrix atoms_atoms_bonds;   ///< 可移动原子间的移动性矩阵
    matrix<distance_type> atoms_inflex_bonds; ///< 可移动原子与不可移动原子的移动性矩阵
    distance_type_matrix inflex_inflex_bonds; ///< 不可移动原子间的移动性矩阵

    // 合并完整的移动性矩阵
    distance_type_matrix mobility_matrix() const {
        distance_type_matrix tmp(atoms_atoms_bonds);
        tmp.append(atoms_inflex_bonds, inflex_inflex_bonds);
        return tmp;
    }
};
```

</div>
</div>

---

## 配体/受体在实际对接中的表示

![配受体类图](https://lbw-img-lbw.oss-cn-beijing.aliyuncs.com/img/202506180016705.png)

---

## 类型说明

- `frame`：定义坐标系的原点位置和旋转方向
- `atom_range`：只有`begin`和`end`字段，用起始和截止索引规定原子范围
- `atom_frame`：派生自`frame`和`atom_range`，集合了一组在同一个坐标系内的原子
- `rigid_body`：没有添加新的字段，支持用刚体构象设置`rigid_body`
- `axis_frame`：添加旋转轴单位向量，他用与轴根位置与坐标系原点的差确定
- `first_segment`：没有添加新的字段，作为tree的根节点
- `segment`：添加了相对父节点的相对旋转和相对坐标

---

## 三种主要结构

- `rigid_body`有完整的6个自由度（平移和旋转），对应配体的根部分
- `first_segment`只能绕固定轴旋转，对应受体的柔性残基必须固定在特定的连接点
- `segment`是相对父节点的旋转分支，对应配体/柔性残基的分支

---

## tree & heterotree

```cpp
template<typename T> // T == segment / first_segmeent
struct tree {
    T node;	 ///< 当前节点
    std::vector< tree<T> > children; ///< 子树向量
};

typedef tree<segment> branch;           ///< 分支类型定义
typedef std::vector<branch> branches;   ///< 分支向量类型定义

template<typename Node> // Node == rigid_body / first_segment
struct heterotree {
    Node node;			///< 根节点
    branches children;	///< 子分支
    heterotree(const Node& node_) : node(node_) {}
};
```

---

## 配体与残基

```cpp
typedef heterotree<rigid_body> flexible_body;
typedef heterotree<first_segment> main_branch;

// ligand(flexible_body(rigid_body(p.atoms[0].a.coords, 0, 0)), torsdof)
struct ligand : public flexible_body, atom_range {
    unsigned degrees_of_freedom; ///< 自由度数量
    interacting_pairs pairs;     ///< 配体内部的相互作用对
    context cont;               ///< 配体的PDBQT文件上下文
	
    ligand(const flexible_body& f, unsigned degrees_of_freedom_) : flexible_body(f), atom_range(0, 0), degrees_of_freedom(degrees_of_freedom_) {}
    
    void set_range();
};

// main_branch(first_segment(ps.immobile_atom_coords(), 0, 0, p_node.a.coords))
struct residue : public main_branch {
    residue(const main_branch& m) : main_branch(m) {}
};
```

---

## 配体后处理

<div style="display: flex; align-items: flex-start;">
<div style="flex: 1; padding-right: 20px;">

**配体后处理流程：**

1. 使用解析树中第一个原子作为配体的根原子，以该根原子的坐标为坐标系原点初始化`ligand`
2. 对分支进行递归的后处理`postprocess_branch`
3. 更新移动性矩阵

</div>
<div style="flex: 1;">

```cpp
void postprocess_ligand(non_rigid_parsed& nr, parsing_struct& p, context& c, unsigned torsdof) {
    VINA_CHECK(!p.atoms.empty());
    nr.ligands.push_back(ligand(flexible_body(rigid_body(p.atoms[0].a.coords, 0, 0)), torsdof)); // postprocess_branch将分配begin和end
    postprocess_branch(nr, p, c, nr.ligands.back());
    nr_update_matrixes(nr); // FIXME ?
}
```

</div>
</div>

---

## 柔性残基后处理

**柔性残基后处理流程：**

1. 把这个残基的所有不可移动原子（ROOT中的所有原子以及直接与ROOT相连的不可移动原子）插入到不可移动集合，并设置对应的`axis_begin`和`axis_end`
2. 对于每一个需要建立的分支（单个不可移动原子不建立分支），都用不可移动原子的位置初始化`main_branch`
3. 对分支进行递归的后处理`postprocess_branch`
4. 更新矩阵

---

## 柔性残基后处理代码

```cpp
void postprocess_residue(non_rigid_parsed& nr, parsing_struct& p, context& c) {
    // 把这个残基的所有不可移动原子插入到不可移动集合；设置axis_begin和axis_end
    VINA_FOR_IN(i, p.atoms) {
        parsing_struct::node& p_node = p.atoms[i];
        p_node.insert_inflex(nr);
        p_node.insert_immobiles_inflex(nr);
    }
    // 处理每一个分支
    VINA_FOR_IN(i, p.atoms) {
        parsing_struct::node& p_node = p.atoms[i];
        VINA_FOR_IN(j, p_node.ps) {
            parsing_struct& ps = p_node.ps[j];
            // 检查该节点是否需要建立分支
            if(!ps.essentially_empty()) { // 不可移动原子已插入 // FIXME ?!
                // 用main_branch创建residue并放入nr的flex向量中
                nr.flex.push_back(main_branch(first_segment(ps.immobile_atom_coords(), 0, 0, p_node.a.coords)));
                postprocess_branch(nr, ps, c, nr.flex.back());
            }
        }
    }
    nr_update_matrixes(nr); // FIXME ?
    VINA_CHECK(nr.atoms_atoms_bonds.dim() == nr.atoms.size());
    VINA_CHECK(nr.atoms_inflex_bonds.dim_1() == nr.atoms.size());
    VINA_CHECK(nr.atoms_inflex_bonds.dim_2() == nr.inflex.size());
}
```

---

## 配体与柔性残基的差异

|                 | 配体      | 柔性残基      |
| --------------- | ------- | --------- |
| ROOT原子          | 可移动集合   | 不可移动集合    |
| 分支immobile_atom | 可移动集合   | 不可移动集合    |
| 分支其他原子          | 可移动集合   | 可移动集合     |
| 分支起始坐标          | 第一个原子坐标 | 不可移动原子的坐标 |

---

## 通用的分支后处理

**分支后处理流程：**

1. 设置当前分支的索引范围
2. 将可移动原子插入`nr.atoms`，计算相对于分支原点的坐标
3. 调整所有距离矩阵的大小以适应新增的可移动原子
4. 键连关系矩阵设置：
    - 建立axis_begin/end原子与当前分支的固定键连
    - 在轴原子间设置旋转键连关系
    - 同一分支内的所有原子间设置为固定距离约束
5. 为每个子分支创建`segment`对象并递归调用自身

---

## 分支后处理代码

```cpp
template<typename B> // B == ligand / residue
void postprocess_branch(non_rigid_parsed& nr, parsing_struct& p, context& c, B& b) {
    // 1. 设置分支节点的原子起始索引
    b.node.begin = nr.atoms.size();

    // 2. 插入可移动原子
    VINA_FOR_IN(i, p.atoms) {
        parsing_struct::node& p_node = p.atoms[i];
        if(p.immobile_atom && i == p.immobile_atom.get()) {}
        else p_node.insert(nr, c, b.node.get_origin());
        p_node.insert_immobiles(nr, c, b.node.get_origin());
    }

    // 设置分支节点的原子结束索引
    b.node.end = nr.atoms.size();

    // 3. 更新键连矩阵
    nr_update_matrixes(nr);

    // 4. 添加轴键连关系
    add_bonds(nr, p.axis_begin, b.node);
    add_bonds(nr, p.axis_end  , b.node);
    set_rotor(nr, p.axis_begin, p.axis_end);

    // 5. 设置同一分支内原子间的固定距离约束
    VINA_RANGE(i, b.node.begin, b.node.end)
        VINA_RANGE(j, i+1, b.node.end)
            nr.atoms_atoms_bonds(i, j) = DISTANCE_FIXED; // FIXME

    // 6. 递归处理子分支
    VINA_FOR_IN(i, p.atoms) {
        parsing_struct::node& p_node = p.atoms[i];
        VINA_FOR_IN(j, p_node.ps) {
            parsing_struct& ps = p_node.ps[j];
            if(!ps.essentially_empty()) { // 不可移动原子已插入 // FIXME ?!
                // 创建子分支段
                b.children.push_back(segment(ps.immobile_atom_coords(), 0, 0, p_node.a.coords, b.node)); // postprocess_branch将分配begin和end
                postprocess_branch(nr, ps, c, b.children.back());
            }
        }
    }
    VINA_CHECK(nr.atoms_atoms_bonds.dim() == nr.atoms.size());
    VINA_CHECK(nr.atoms_inflex_bonds.dim_1() == nr.atoms.size());
    VINA_CHECK(nr.atoms_inflex_bonds.dim_2() == nr.inflex.size());
}
```

---

