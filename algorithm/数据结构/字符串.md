```dataview
LIST FROM [[字符串]]
```
## KMP算法

KMP算法用于解决在字符串匹配时遇到的问题：当子串匹配失败时，最简单的做法是当第`i`个字符开始的子串匹配失败时，从`i+1`处从头重新匹配，时间复杂度为$O(mn)$。这样做浪费了很多在匹配子串时获得的信息，导致时间复杂度很高。

那KMP算法是怎么做的呢？给出两个字符串作为例子，分别为`S`和`P`：
- `ACTGPACTGKACTGPACY`
- `ACTGPACY`
显然当`i=10`时才能匹配上。但是对于计算机来说，他会在`i=0`就开始匹配，并在`i=7`时发现匹配错误。这时我们不需要回到`i=1`处重新匹配，因为`i=7`时字符串`S`有前缀`ACT`与字符串`P`匹配。那么怎么确认这个可以匹配的前缀呢？

很简单，对于`ACTGPACY`这个字符串，如果可以匹配到最后一个字符`Y`，那么即使匹配失败也可以从`T`开始重新匹配，这是因为`Y`前面的字符串`ACTGPAC`有着相同的前缀/后缀`AC`。下面就只需要用一个数组来记录到位置`j`，他与字符串相同的前缀/后缀长度，该数组称为`next`数组。

`next[i]` 表示 `P[0..i-1]` 的最长公共前后缀长度，即：
- **前缀**：`P[0..k-1]`（真前缀，不包含 `P[0..i-1]` 本身）
- **后缀**：`P[i-k..i-1]`（真后缀，不包含 `P[0..i-1]` 本身）
**示例**：  
模式串 `P = "ababc"`，`i=3`（子串 `"aba"`）：
- 前缀：`"a"`, `"ab"`（真前缀不包括 `"aba"`）
- 后缀：`"a"`, `"ba"`
- 最长公共前后缀是 `"a"`，长度 `1`，所以 `next[3] = 1`
当字符串匹配到`P[3]`时，如果匹配失败，由于`next[3]=1`，我们知道，此时只需要回退到`P[1]`继续匹配即可。

怎么通过代码获得这个数组呢？
分别放置两个指针，`i=0`指向字符串的索引，`j=-1`为当前公共前后缀的长度，`next[0]=-1,next[1]=0`。之后的`next`可以由递推得到，比如`next[7]`需要先判断`s[0]`和`s[6]`是否相等，若不相等则显然`next[7]=0`；若相等则继续加上`next[6]`，因为`next[6]`存储了`0-5`这个范围内子串的最长公共前后缀长度。
```cpp
vector<int> buildNext(string s){
	int len = s.size();
	vector<int> next(len);
	int i = 0, j = -1;	
	while(i < len - 1){
		if(j < 0 || s[i] == s[j]){			
			i++,j++;
			next[i] = j;
			// 可以写成next[++i] = ++j;
		}else{
			j = next[j];
		}
	}
	return next;
}
```

接下来就是用`next`数组完成KMP算法：
```cpp
int KMP(string S, string P){
	vector<int> next = buildNext(P);
	int m = S.size(), n = P.size(), i = 0, j = 0;
    while(j < n && i < m){
	    if(j < 0 || S[i] == P[j]){
			i++,j++;
		}else{
			j = next[j];
		}
	}
	if(j != n) return -1;
	return i-j;
}
```
